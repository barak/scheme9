; Scheme 9 from Empty Space, Function Library
; By Nils M Holm, 2009
; See the LICENSE file of the S9fES package for terms of use
;
; The S9fES Scientific Calculator Package

(load-from-library "iota.scm")
(load-from-library "mergesort.scm")

(define *XLIM* 13333)
(define *YLIM* 10000)

(define *X0* #f)
(define *XN* #f)
(define *Y0* #f)
(define *YN* #f)
(define *X-size* #f)
(define *Y-size* #f)
(define *X-scale* #f)
(define *Y-scale* #f)
(define *X-step* #f)
(define *Y-step* #f)
(define *X-zero* #f)
(define *Y-zero* #f)

(define (int x)
  (inexact->exact (round x)))

(define-syntax define-range-function
  (syntax-rules ()
    ((_ name p0 pN Gp0 GpN Gsize Gscale Gstep Gzero GLIM)
      (define (name p0 pN . s)
        (if (not (<= p0 0 pN))
            (wrong "SC: range must be in range x0..xN")
            (let* ((width (if (negative? p0)
                              (if (negative? pN)
                                  (- (abs p0) (abs pN))
                                  (+ (abs p0) pN))
                              (- pN p0)))
                   (steps (if (null? s)
                              20
                              (/ width (car s))))
                   (zero  (- width pN)))
              (set! Gp0 p0)
              (set! GpN pN)
              (set! Gsize width)
              (set! Gscale (/ GLIM width))
              (set! Gstep (/ width steps))
              (set! Gzero (int (* zero Gscale)))))))))

(define-range-function
  x-range x0 xN *X0* *XN* *X-size* *X-scale* *X-step* *X-zero* *XLIM*)

(define-range-function
  y-range y0 yN *Y0* *YN* *Y-size* *Y-scale* *Y-step* *Y-zero* *YLIM*)

(define (label-string x)
  (number->string (abs x)))

(define (plot-x-axis ticks labels lstep)
  (gfx:line 0 *Y-zero* *XLIM* *Y-zero* #t)
  (if ticks
      (let loop ((x *X0*))
        (cond ((<= x *XN*)
                (let ((rx (int (+ *X-zero* (* x *X-scale*)))))
                  (gfx:line rx (- *Y-zero* 100) rx (+ *Y-zero* 100) #t)
                  (loop (+ x *X-step*)))))))
  (cond
    (labels
      (let loop ((x *X-step*)
                 (xs (+ *X-zero* (* *X-step* *X-scale*)))
                 (ls (if (= 1 lstep) 1 (- lstep 1))))
        (cond ((<= x *XN*)
                (let* ((s  (label-string x))
                       (rx (int (- xs (quotient (gfx:string-width s 1) 2)))))
                  (if (= ls lstep)
                      (gfx:put-string rx (+ *Y-zero* 150) 1 #t s))
                  (loop (+ x *X-step*)
                        (+ xs (* *X-scale* *X-step*))
                        (if (< ls 2) lstep (- ls 1)))))))
      (let loop ((x (- *X-step*))
                 (xs (- *X-zero* (* *X-step* *X-scale*)))
                 (ls (if (= 1 lstep) 1 (- lstep 1))))
        (cond ((>= x *X0*)
                (let* ((s  (label-string x))
                       (rx (int (- xs (quotient (gfx:string-width s 1) 2)))))
                  (if (= ls lstep)
                      (gfx:put-string rx (+ *Y-zero* 150) 1 #t s))
                  (loop (- x *X-step*)
                        (- xs (* *X-scale* *X-step*))
                        (if (< ls 2) lstep (- ls 1))))))))))

(define (plot-y-axis ticks labels lstep)
  (gfx:line *X-zero* 0 *X-zero* *YLIM* #t)
  (if ticks
      (let loop ((y *Y0*))
        (cond ((<= y *YN*)
                (let ((ry (int (+ *Y-zero* (* y *Y-scale*)))))
                  (gfx:line (- *X-zero* 100) ry (+ *X-zero* 100) ry #t)
                  (loop (+ y *Y-step*)))))))
  (cond
    (labels
      (let loop ((y *Y-step*)
                 (ys (+ *Y-zero* (* *Y-step* *Y-scale*)))
                 (ls (if (= 1 lstep) 1 (- lstep 1))))
        (cond ((<= y *YN*)
                (let ((ry (int (- ys 50)))
                      (s  (label-string y)))
                  (if (= ls lstep)
                      (gfx:put-string (+ *X-zero* 150) ry 1 #t s))
                  (loop (+ y *Y-step*)
                        (+ ys (* *Y-scale* *Y-step*))
                        (if (< ls 2) lstep (- ls 1)))))))
      (let loop ((y (- *Y-step*))
                 (ys (- *Y-zero* (* *Y-step* *Y-scale*)))
                 (ls (if (= 1 lstep) 1 (- lstep 1))))
        (cond ((>= y *Y0*)
                (let ((ry (int (- ys 50)))
                      (s  (label-string y)))
                  (if (= ls lstep)
                      (gfx:put-string (+ *X-zero* 150) ry 1 #t s))
                  (loop (- y *Y-step*)
                        (- ys (* *Y-scale* *Y-step*))
                        (if (< ls 2) lstep (- ls 1))))))))))

(define (get-value key args . dfl)
  (cond ((memv key args)
          => (lambda (x)
               (if (pair? (cdr x))
                   (cadr x)
                   (if (null? dfl) #f (car dfl)))))
        ((null? dfl)
          #f)
        (else
          (car dfl))))

(define (setup-grid x0 xN y0 yN . args)
  (let ((x-step   (get-value 'x-step: args))
        (y-step   (get-value 'y-step: args))
        (x-ticks  (get-value 'x-ticks: args #t))
        (y-ticks  (get-value 'y-ticks: args #t))
        (x-labels (get-value 'x-labels: args #t))
        (y-labels (get-value 'y-labels: args #t))
        (x-lstep  (get-value 'x-lstep: args 1))
        (y-lstep  (get-value 'y-lstep: args 1))
        (noplot   (get-value 'noplot: args #f)))
    (if x-step
        (x-range x0 xN x-step)
        (x-range x0 xN))
    (if y-step
        (y-range y0 yN y-step)
        (y-range y0 yN))
    (if (not noplot)
        (begin (gfx:clear)
               (plot-x-axis x-ticks x-labels x-lstep)
               (plot-y-axis y-ticks y-labels y-lstep)))))

(define (line-plot-fn fn . args)
  (let ((res  (get-value 'res: args 100))
        (from (get-value 'from: args *X0*))
        (to   (get-value 'to: args *XN*)))
    (let ((step  (/ *X-size* res))
          (sstep (* *X-scale* (/ *X-size* res))))
      (let loop ((x  *X0*)
                 (xs (int (+ *X-zero* (* *X-scale* *X0*))))
                 (px #f)
                 (py #f))
        (let* ((y (fn x))
               (y (if (number? y)
                      (int (* *Y-scale* y))
                      y)))
          (cond ((<= x *XN*)
                  (cond ((and (<= from x to)
                              (number? y))
                          (if px (gfx:line px
                                           (+ *Y-zero* py)
                                           (int xs)
                                           (+ *Y-zero* y)
                                           #t))
                          (loop (+ x step) (+ xs sstep) (int xs) y))
                        (else
                          (loop (+ x step) (+ xs sstep) #f #f))))))))))

(define (scatter-mark style)

  (define (scatter-0 x y)
    (gfx:box (- x 50) (- y 50)
             (+ x 50) (+ y 50) #t #f))

  (define (scatter-1 x y)
    (gfx:box (- x 50) (- y 50)
             (+ x 50) (+ y 50) #t #t))

  (define (scatter-2 x y)
    (gfx:ellipse (- x 50) (- y 50)
                 (+ x 50) (+ y 50) #t #f))

  (define (scatter-3 x y)
    (gfx:ellipse (- x 50) (- y 50)
                 (+ x 50) (+ y 50) #t #t))

  (define (scatter-4 x y)
    (gfx:line (- x 50) (- y 50)
              (+ x 50) (+ y 50) #t)
    (gfx:line (- x 50) (+ y 50)
              (+ x 50) (- y 50) #t))

  (case style
    ((0)  scatter-0)
    ((1)  scatter-1)
    ((2)  scatter-2)
    ((3)  scatter-3)
    ((4)  scatter-4)
    (else (wrong "scatter-mark: style: must be in range 0..4"
          style))))

(define (scatter-plot-fn fn . args)
  (let ((style (get-value 'style: args 0))
        (res   (get-value 'res: args 100))
        (from (get-value 'from: args *X0*))
        (to   (get-value 'to: args *XN*)))
    (let* ((step  (/ *X-size* res))
           (sstep (* *X-scale* (/ *X-size* res)))
           (box   (scatter-mark style)))
      (let loop ((x  *X0*)
                 (xs (int (+ *X-zero* (* *X-scale* *X0*)))))
        (let* ((y (fn x))
               (y (if (number? y)
                      (int (* *Y-scale* y))
                      y)))
          (if (<= x *XN*)
              (begin (if (and (<= from x to)
                              (number? y))
                         (box (int xs) (+ y *Y-zero*)))
                     (loop (+ x step) (+ xs sstep)))))))))

(define (pin-plot-fn fn . args)
  (let ((res  (get-value 'res: args 100))
        (from (get-value 'from: args *X0*))
        (to   (get-value 'to: args *XN*)))
    (let ((step  (/ *X-size* res))
          (sstep (* *X-scale* (/ *X-size* res))))
      (let loop ((x  *X0*)
                 (xs (int (+ *X-zero* (* *X-scale* *X0*)))))
        (let* ((y (fn x))
               (y (if (number? y)
                      (int (* *Y-scale* y))
                      y)))
          (if (<= x *XN*)
              (begin (if (and (<= from x to)
                              (number? y))
                       (gfx:line (int xs) *Y-zero* (int xs) (+ y *Y-zero*) #t))
                     (loop (+ x step) (+ xs sstep)))))))))

(define (filled-box x y dx dy step)
  (let ((x  (min x dx))
        (dx (max x dx))
        (y  (min y dy))
        (dy (max y dy)))
    (gfx:box x y dx dy #t #f)
      (if (positive? step)
          (let yloop ((j (+ y (quotient step 2))))
            (let xloop ((i (+ x (quotient step 2))))
              (if (< i (- dx 10))
                  (begin (gfx:box i j (+ i 10) (+ j 10) #t #f)
                         (xloop (+ i step)))
                  (if (< j (- dy step 10))
                      (yloop (+ j step)))))))))

(define (fill-style n)
  (cond ((assv n '((0 0) (1 200) (2 150) (3 100) (4 50)))
          => cadr)
        (else 0)))

(define (bar-plot-fn fn . args)
  (let ((res   (get-value 'res: args 100))
        (style (fill-style (get-value 'style: args 0)))
        (from (get-value 'from: args *X0*))
        (to   (get-value 'to: args *XN*)))
    (let ((step  (/ *X-size* res))
          (sstep (* *X-scale* (/ *X-size* res))))
      (let loop ((x  *X0*)
                 (xs (int (+ *X-zero* (* *X-scale* *X0*)))))
        (let* ((y (fn x))
               (y (if (number? y)
                      (int (* *Y-scale* y))
                      y)))
          (if (<= x *XN*)
              (begin (if (and (<= from x (- to step))
                              (number? y))
                         (filled-box (int xs)
                                     *Y-zero*
                                     (int (+ xs sstep))
                                     (+ y *Y-zero*)
                                     style))
                     (loop (+ x step) (+ xs sstep)))))))))

(define (dry-plot-fn fn . args)
  (let ((res     (get-value 'res: args 100))
        (from    (get-value 'from: args *X0*))
        (to      (get-value 'to: args *XN*))
        (min-val #f)
        (max-val #f))
    (let* ((step  (/ *X-size* res))
           (sstep (* *X-scale* (/ *X-size* res))))
      (let loop ((x  *X0*)
                 (xs (int (+ *X-zero* (* *X-scale* *X0*)))))
        (let* ((y (fn x)))
          (if (<= x *XN*)
              (begin (if (and (<= from x to)
                              (number? y))
                         (begin (if (or (not min-val)
                                        (< y min-val))
                                    (set! min-val y))
                                (if (or (not max-val)
                                        (> y max-val))
                                    (set! max-val y))))
                     (loop (+ x step) (+ xs sstep)))
              (list min-val max-val)))))))

(define (plot-fn fn . args)
  (let* ((type (get-value 'type: args 'line))
         (proc (case type
                 ((scatter) scatter-plot-fn)
                 ((pin)     pin-plot-fn)
                 ((bar)     bar-plot-fn)
                 ((dry)     dry-plot-fn)
                 (else      line-plot-fn))))
    (apply proc fn args)))

(define (intersperse a k lim)
  (let ((r (/ lim k)))
    (let loop ((a  a)
               (sa '())
               (i  r))
      (cond ((null? a)
              (reverse sa))
            ((positive? i)
              (loop a (cons #f sa) (- i 1)))
            (else
              (loop (cdr a) (cons (car a) sa) (+ i r)))))))

(define (plot-set set . args)
  (let* ((spread (get-value 'spread: args #f))
         (res    (get-value 'res: args 100)))
    (let* ((k    (length set))
           (set  (if (or (null? set) (pair? (car set)))
                     set
                     (map cons (iota 0 (- k 1)) set)))
           (set  (mergesort (lambda (a b) (< (car a) (car b)))
                            set))
           (vset (if spread
                     (list->vector (intersperse (map cdr set) k res))
                     (list->vector (map cdr set))))
           (k    (vector-length vset))
           (fn   (lambda (x)
                   (if (< x k)
                       (vector-ref vset (int x))
                       #f))))
      (apply plot-fn fn args))))

(define (plot mapping . args)
  (if (procedure? mapping)
      (apply plot-fn mapping args)
      (apply plot-set mapping args)))

(define (auto-plot x0 xN mapping . args)
  (setup-grid x0 xN -1 1 'noplot: #t)
  (let* ((y0/yN (apply plot mapping 'from: x0 'to: xN 'type: 'dry args))
         (y0    (min 0 (car y0/yN)))
         (yN    (cadr y0/yN)))
    (apply setup-grid x0 xN y0 yN args)
    (apply plot mapping args)))

(define (display-key . labels)
  (let* ((h      (gfx:string-height "" 1))
         (height (* (length labels) h))
         (width  (+ (gfx:string-width "  - " 1)
                    (apply max (map (lambda (x)
                                      (gfx:string-width (cadr x) 1))
                                    labels)))))
    (let ((x  (- *XLIM* width 300))
          (y  (- *YLIM* 100))
          (dx (- *XLIM* 100))
          (dy (- *YLIM* height 300)))
      (gfx:box x y dx dy #f #t)
      (gfx:box x y dx dy #t #f)
      (for-each (lambda (lab pos)
                  (gfx:put-string (+ x 200)
                                  (- y 250 (* pos h))
                                  1
                                  #t
                                  (string-append " - " (cadr lab)))
                  ((scatter-mark (car lab))
                   (+ x 150) (- y 200 (* pos h))))
                labels
                (iota 0 (- (length labels) 1))))))
