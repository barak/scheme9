S9fES  (define-macro <symbol> <procedure>)                    ==>  unspecific
       (define-macro (<symbol1> <symbol2> ...) <expression>)  ==>  unspecific

DEFINE-MACRO binds a procedure to a symbol. Like DEFINE it has two
forms. The first form binds <symbol1> to the procedure in its second
argument. The second form binds <symbol1> to

(lambda (<symbol2> ...) <expression>).

The procedures bound by DEFINE-MACRO may be variadic.

Procedures bound by DEFINE-MACRO are commonly called "macros". They
receive their arguments in textual (unevaluated) form and they are
called at "read time." When an expression containing a macro application
is being read, the macro is applied to its arguments before the
containing expression is evaluated. The application of the macro is
replaced by the value returned by the macro.

(define-macro when
  (lambda (pred . conseq)
    `(if ,pred (begin ,@conseq))))

(when (= 1 1)
      (display "true")
      #t)               ==>  #t

Macros may not recurse directly, but they may implement recursion
internally using LETREC or by rewriting their own applications. The
following macro, for example, does not work, because D is undefined
in the body of D:

(define-macro (d x) (and (pair? x) (d (cdr x)))) ; WRONG!

The following version does work, though, because the macro gets
rewritten to another application of itself, which is subsequently
evaluated:

(define-macro (d x) (and (pair? x) `(d ,(cdr x)))) ; OK
