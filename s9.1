.\" S9(1) Manual Page
.\" By Nils M Holm, 2007, 2008, 2009
.ll 70
.lt 70
.ds N "pi
.de HD		\" Header
'sp 1v
.tl 'S9(1)'Scheme 9 from Empty Space'S9(1)'
'sp 2v
..
.de FO		\" Footer
'sp 3v
.tl 'S9 Interpreter'Page %'S9(1)'
'bp
..
.de B
\fB\\$1\fP
..
.de BR
\fB\\$1\fP\\$2
..
.de IR
\fI\\$1\fP\\$2
..
.de RB
\\$1\fB\\$2\\fP
..
.de I
\fI\\$1\fP
..
.de SH		\" subheader macro
.ne 5
.sp
.in 0i
.nf
\fB\\$1\fP
.fi
.in 1i
..
.de ST		\" start a table
.in 1i
.nf
..
.de ET		\" end a table
.fi
.in 0
..
.wh 0 HD	\" traps for header
.wh -5 FO	\" and footer
.nh		\" disable hyphenation
.sp
.SH NAME
.B "s9
- Scheme Interpreter
.SH USAGE
.B "s9 [-h?] [-gnqv] [-m size[m]] [-f program] [-d image] [-i]
.SH "DESCRIPTION
.B "Scheme 9 from Empty Space
is an interpreter for a broad subset of
R4RS Scheme. The
.B s9
command starts the interpreter.
.SH "OPTIONS
.B "-h or -?
.in +4
Display a brief summary of options.
.in -4
.B "-d file
.in +4
Dump heap image to
.I file
and exit.
.in -4
.B "-f program
.in +4
Run
.I program
and exit (may be repeated, implies -q).
.in -4
.B "-g
.in +4
Print GC summaries (\fB-gg\fP = more verbose).
.in -4
.B "-i
.in +4
Enter interactive mode (after
.BR -f ).
.in -4
.B "-n
.in +4
Do not load
.I $HOME/.s9fes/rc
file, if any.
.in -4
.B "-m N[m]
.in +4
Set memory limit to
.I N
kilo (or mega) nodes.
.in -4
.B "-q
.in +4
Be quiet: skip banners and prompts, exit on errors.
.in -4
.B -v
.in +4
Display version and exit.
.in -4
.B --
.in +4
Arguments following
.B --
are not interpreted by S9fES.
.in -4
.SH "ONLINE HELP
When the interpreter is running and the default heap image is loaded,
just type
.sp
\fB(help)\fP
.sp
to invoke the online help system. When using a custom heap image that
does not contain the online help system, you will have to
run the following command first:
.sp
\fB(load-from-library "help.scm")\fP
.SH "TECHNICAL DETAILS
S9fES is a tree-walking interpreter using deep binding and hashed
environments. It employs a constant-space mark and sweep garbage
collector with in-situ string and vector pool compaction. Memory
pools grow on demand.
.br
The interpreter uses bignum integer arithmetics exclusively.
It provides both low-level macros (see
.B MACROS
below) and \fBdefine-syntax\fP/\fBsyntax-rules\fP.
.SH "ADDITIONS
These S9fES procedures are not in R4RS:
.sp
.ne 3
.B "(delete-file string) ==> unspecific
.in +4
Delete the file specifed in the
.I string
argument. If the file does not exist
or cannot be deleted, report an error.
.in -4
.br
.ne 3
.B "(expand-quasiquote form) ==> expanded-form
.in +4
If
.I form
is a quasiquoted expression, rewrite it as an equivalent expression
that does not use quasiquotation.
.in -4
.br
.ne 3
.B "(expand-macro form) ==> expanded-form
.in +4
If
.I form
applies a macro, return the expanded form, else return the form.
.in -4
.br
.ne 3
.B "(file-exists? string) ==> boolean
.in +4
Return
.B "#t
if the file specifed in the
.I string
argument exists and otherwise \fB#f\fP.
.in -4
.br
.ne 4
.B "(fold-left proc base list ...) ==> form
.in +4
Combine the elements of the
.IR list s
using
.IR proc .
Combine elements left-associatively.
.I Base
is the leftmost element.
.in -4
.br
.ne 4
.B "(fold-right proc base list ...) ==> form
.in +4
Combine the elements of the
.IR list s
using
.IR proc .
Combine elements right-associatively.
.I Base
is the rightmost element.
.in -4
.br
.B "(gensym) ==> symbol
.br
.B "(gensym string) ==> symbol
.in +4
Return a fresh symbol. When a
.I string
argument is given, use it as prefix for the fresh symbol.
.in -4
.br
.ne 2
.B "(load-from-library string) ==> unspecific
.in +4
Attempt to
.B load
the file
.I string
from each directory of
.IR S9FES_LIBRARY_PATH .
.in -4
.br
.ne 2
.B "(locate-file string) ==> string | #f
.in +4
Search for the file
.I string
in each  directory of
.B S9FES_LIBRARY_PATH
in sequence.
When the file can be located, return its full path, else
return \fB#f\fP.
.in -4
.br
.ne 2
.B "(print form ...) ==> unspecific
.in +4
Write multiple
.IR form s
separated by spaces.
.in -4
.br
.ne 2
.B "(set-input-port! input-port) ==> unspecific
.in +4
Destructively set the current input port.
.in -4
.br
.ne 2
.B "(set-output-port! output-port) ==> unspecific
.in +4
Destructively set the current output port.
.in -4
.br
.ne 2
.B "(stats form) ==> normal form
.in +4
Evaluate the given
.I form
and return its normal form. In addition, print the number
of reduction steps, nodes allocated, and garbage collections
performed during evaluation. Note that
.I form
must be quoted.
.in -4
.br
.ne 2
.B "(symbols) ==> list
.in +4
Return a list of all defined symbols.
.in -4
.br
.ne 3
.B "(trace symbol ...) ==> list | #t
.br
.B "(trace #t) ==> list | #t
.in +4
Trace the procedure or syntax bound to the given
.IR symbols .
When
.B #t
is passed to
.BR trace ,
trace
.I all
procedures and syntax (\fIexpect lots of output!\fP). When no arguments are
passed to it, disable tracing.
.B Trace
returns the symbols that were being traced before its invocation.
.in -4
.br
.ne 3
.B "(void) ==> unspecific
.in +4
Return an unspecific value.
.in -4
.br
.ne 3
.B "(wrong string form) ==> bottom
.in +4
Print an error message of the form
.I "error: string: form
and terminate program execution.
.I Form
may be omitted.
.in -4
.sp
Redefinition of these procedures is safe except for
.BR expand-quasiquote
and
.BR wrong .
.SH "VARIABLES
These variables are pre-defined in the dynamic top-level scope of the
interpreter.
.sp
.ne 2
.B "** (form)
.in +4
The normal form of the expression most recently evaluated at the
top level.
.in -4
.ne 2
.B "*extensions* (list of symbols)
.in +4
Compiled-in extensions.
.in -4
.ne 2
.B "*library-path* (string)
.in +4
A verbatim copy of the
.I S9FES_LIBRARY_PATH
environment variable (see below).
.in -4
.ne 2
.B "*loading* (boolean)
.in +4
Set to
.B #t
when \fBload\fPing a file, else \fB#f\fP.
.in -4
.SH "MACROS
A S9fES macro is a procedure that is applied to its unevaluated arguments.
The macro application is replaced with the value returned by the procedure.
This happens before the expression containing the macro application is
evaluated, so a macro
.I rewrites
its own application:
.sp
.ne 2
.nf
(define-macro (when p . c)
  `(if ,p (begin ,@c)))
(expand-macro '(when (= 1 1) (display "true") (newline) #t))
  ==>  (if (= 1 1)
           (begin (display "true")
                  (newline)
                  #t))
(when (= 1 1) 1 2 3)  ==>  3
.fi
.sp
The
.B define-macro
form introduces a new macro:
.sp
.ne 3
.B "(define-macro name procedure) ==> unspecific
.br
.B "(define-macro (name args ...) body) ==> unspecific
.sp
Both of these forms introduce the keyword
.I name
and bind it to a procedure. The first form requires the
second argument to be a procedure. Like in
.B define
forms the second variant implies a procedure definition.
.sp
Macros may contain applications of macros that were defined earlier.
Macros may not recurse directly, but they may implement recursion
internally using
.B letrec
or by rewriting their own applications. The following macro,
for example, does
.I not
work, because
.I d
is undefined in the body of
.IR d :
.sp
.B "(define-macro (d x) (and (pair? x) (d (cdr x)))) ; wrong"
.sp
The following version
.I does
work, though:
.sp
.B "(define-macro (d x) (and (pair? x) `(d ,(cdr x)))) ; OK"
.SH "ALLOCATION STRATEGY
The S9fES memory pool grows exponentially until the memory limit
its reached. When the limit is reached, the current computation
is aborted. A memory limit can be specified using the
.B -m
command line option. The limit is specified in units of 1024
nodes (or in units of 1024*1024 nodes by appending an
.B m
suffix).
.br
Note that computations may abort
.I before
the limit is reached due to the way the pool grows. Use the
.B -g
command line option to experiment with pool sizes.
.br
Specifying a memory limit of zero disables the memory limit and
the interpreter will allocate as much memory as it can get. This
option should be used with care.
.SH "LIMITATIONS
These parts of R4RS are not implemented:
.sp
Control:
.BR call-with-current-continuation .
.br
I/O:
.BR char-ready? .
.br
Transcripts:
.BR transcript-off ,
.BR transcript-on .
.br
Numeric tower: rational, float, complex numbers.
.br
Numeric syntax and procedures:
.BR #e ,
.BR #i ,
.BR / ,
.BR acos ,
.BR angle ,
.BR asin ,
.BR atan ,
.BR ceiling ,
.BR complex? ,
.BR cos ,
.BR denominator ,
.BR exact->inexact ,
.BR exact? ,
.BR exp ,
.BR floor ,
.BR imag-part ,
.BR inexact->exact ,
.BR inexact? ,
.BR log ,
.BR magnitude ,
.BR make-polar ,
.BR make-rectangular ,
.BR numerator ,
.BR rational ,
.BR rationalize ,
.BR real-part ,
.BR real? ,
.BR round ,
.BR sin ,
.BR sqrt,
.BR tan ,
.BR truncate .
.SH "BUGS
Nested quasiquotation is currently unsupported.
.SH "FILES
.ne 2
.B $HOME/.s9fes/rc
.in +4
If present, this file is
.BR load ed
when the interpreter starts up.
.in -4
.ne 2
.B @LIBDIR@
.in +4
The S9fES procedure library (source code).
.in -4
.ne 2
.B @LIBDIR@/contrib
.in +4
Contributions to the procedure library (source code).
.in -4
.ne 2
.B @LIBDIR@/s9.image
.in +4
The interpreter heap image.
.in -4
.ne 2
.B *.scm
.in +4
Scheme source code.
.in -4
.SH "ENVIRONMENT
.B S9FES_LIBRARY_PATH
.in +4
A colon-separated list of directories which will be searched for
the s9 library when the interpreter is launched. The same directories
will be search by the
.B locate-file
procedure.
.br
Default:
.I \&.:~/.s9fes:@LIBDIR@:@LIBDIR@/contrib
.in -4
.SH "SIGNALS
These work only if POSIX signal handling was enabled at compile time.
.sp
.ne 3
.B "SIGINT
.in +4
Abort input or terminate program execution.
.in -4
.ne 3
.B "SIGQUIT
.in +4
Terminate the interpreter process (emergency exit).
.in -4
.SH "REFERENCES
.ne 3
.B "http://www-swiss.ai.mit.edu/~jaffer/r4rs_toc.html
.in +4
The Revised^4 Report on the Algorithmic Language Scheme.
.in -4
.sp
.ne 3
.B "http://www.lulu.com/content/1010408
.br
.B "http://t3x.org/nmh/book-pdfs/scheme-9-from-empty-space.zip"
.in +4
Scheme 9 from Empty Space -- A Guide to Implementing Scheme in C.
.in -4
.SH AUTHOR
Nils M Holm < nmh at t3x.org >
